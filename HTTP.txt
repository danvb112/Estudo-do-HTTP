HTTP

- No momento em que voçê acessa um site, existe uma comunicação entre o navegador e o servidor chamada
de Client-Server. Este é um modelo arquitetural, ou seja, a internet inteira é baseada nesta arquitetura
onde há um cliente que solicita e um servidor que responde.

- Em qualquer comunicação, é preciso existir algumas regras para que as duas partes consigam se entender
com sucesso. Pensando na comunicação entre o navegador e o servidor, esse conjunto de regras é basica-
mente um protocolo, onde neste cenário é o HTTP

- Resumindo: O HTTP (Hypertext Transfer Protocol) é um protocolo que define as regras de comunicação 
entre cliente e servidor na internet

- Nesse modelo, o navegador representa o cliente

- O modelo Cliente-Servidor não é o único modelo de comunicação na rede, nem sempre o mais adequado. Por
exemplo, imagine que precisemos contar as letras de 20 palavras. No caso do modelo Cliente-Servidor,
quem fará esse trabalho é o servidor. E se precisar contar as letras de 1 milhão de palavras? muito tra-
balhoso para o servidor...

- O modelo Cliente-Servidor tenta centralizar o trabalho no servidor, mas isso também pode gerar gar-
galos. Se cada cleinte pudesse ajudar no trabahlo, ou seja, assumir um pouco da responsabilidade do ser-
vidor, seria muito mais rápido. Essa é a ideia do P2P (torrents por exemplo)! não há mais uma clara 
divisão entre Cliente-Servidor, cada cliente também é servidor e vice-cersa.

- Há arquiteturas muito mais complexas, mas a grande maioria usa o protocolo HTTP no topo. O protocolo
HTTP garante a conectividade. Isso quer dizer que o protocolo HTTP funciona em todos os lugares, sem
ter problemas com firewalls e outras regras de segurança. Nós podemos nos conectar sem maiores problemas
com qualquer servidor no mundo!

- Quando usamos o HTTP, todos os dados enviados entre cliente e servidor são transmitidos em texto puro,
inclusive dados sensíveis, como login e senha. Essas informações são enviadas em texto limpo e é possi-
vel vizualiza-las pelas ferramentas do desenvolvedor do navegador. A aba network nos possibilita isso.

- Quando o navegador pede informações, nessa comunicação existem vários intermediários. Por exemplo,
usando uma conexão WI-FI, os dados do navegador passam primeiro para o roteador WI-FI, e do roteador
passam para o modem do provedro, do modem para algum servidor do provedor, do modem para algum servidor
do provedor de internet, como Oi ou NET.

- O problema é, quando usamos HTTP, qualquer servidor no meio pode espionar dados enviados, algo total-
mente inseguro! Para estes outros cenários, existe o HTTPSm que basicamente é o HTTP comum, porém com 
uma camada adicional de segurança/criptografia que antes era SSL, mas posteriormente passou a ser tam-
bém TLS. é muito comum que estas duas siglas sejam encontradas juntas como SSL/TLS por se tratarem da 
mesma questão de segurança. Sendo assim, temos dois termos:
1. HTTP: HyperText Transfer Protocol
2. SSL/TLS: Secure Sockets Layer / Transport Layer Security

- O HTTPS para garantir a segurança usa criptograia baseada em chaves públicas e privadas e para gerar
essas chaves publicas e privadas é preciso garantir a identidade de quem possui essas chaves e isso é
feito a partir de um certificado digital, ou seja, um certificado digital é utilizado para identificar
determinada entidade e ainda é utilizada para geração de criptografia.

- Apesar disso, ainda é necessário que uma autoridade certificadora, que nada mais é do que um orgão ou
entidade confiável, garanta não apenas a identidade do site mas também a validade do certificado.

- OS navegadores em posse da chave pública criptografam as informações e as enviam para o servidor
que as descriptografa com a chave privada. É importante notar que apenas a chave privada descriptografa
as informações criptografadas com a pública, e também que deve-se manter a chave privada segura.

- Como temos duas chaves envolvidas, esse método de criptografia é chamado de criptografia assimetrica
e tem um problema, ela é lenta.

- Por outro lado temos a criptografia simétrica, que usa a mesma chave para cifrar e decifrar os dados
como na vida real, onde usamos a mesma chave para abrir e fechar a porta. A criptografia simétrica é 
muito mais rápida, mas infelizmente não tão segura. como exite apenas uma chave, ela ficará espalhada 
pelos clientes (navegadores) e qualquer um que tenha posse dessa chave, pode decifrar a comunicação.

- O interessante é que o HTTPS usa ambos os métodos de criptografia, simétrica e assimétrica.

- No certificado, vem a chave pública para o cliente utilizar e o servidor continua de posse da chave
privada. Isso é seguro, mas lento por isso o cliente gera uma chave simétrica ao vivo. Uma chave só pra
ele e o servidor com o qual está se comunicando naquele momento. Essa chave exclusiva (e simétrica) é
então enviada para o servidor utilizando uma criptografia assimétrica (chave pública e privada) e então
é usada para o restante da comunicação.

- Então o HTTPS começa com criptografia assimétrica para depois mudar para criptografia simétrica. Essa 
chave simétrica será gerada no inicio da comunicação e será reaproveitada nas requuisições seguintes.

- Já sabemos que o endereço começa com http ou https. Repare que depois do nome do protocolo, vem ://
seguido pelo nome do site. No vocabulário do desenvolvedor "www.alura.com.br" é o domínio (ou domain).
A abreviação "www" representa "world wide web"

- Olhando da direita para esquerda, o domínio que começa com "br", indicando um site do Brasil. O "br"
representa o "top level domain", está na raiz do domínio. Depois vem o "com" abreviação de comercial e
"alura". O "com" e o "alura" são sub-domínios. 

- O "www" representa também um sub-domínio, no entanto o seu uso é opcional, tanto que "alura.com.br" e
"www.alura.com.br" funcionam e mostram a mesma página.

- Existe também a ideia de sub-domínios que representam sessões dentro de um site. Por exemplo no caso
do Gmail temos: "mail.google.com" ou ainda no caso do google drive, temos: "drive.google.com". Tanto o
Gmail quanto o Drive são sub-dominios do domínio Google.

- O nome do domíno pe organizado em uma hierarquia que foi criada para organizar os sites na internet
e para a gente ter algo fácil para se lembrar. A internet funciona na verdade sem esses domínios. As 
máquinas na internet tem outra forma de se endereçar. Elas usam o que se chama endereços de IP, que 
nada mais são do que números, muito difícil para a gente decorar.

- Mas a gente não acessa o Google por um número e sim pela URL. Acontece que por debaixo dos panos quan-
do realizamos uma requisição essa URL é trasformada em um número por um serviço trasparente chamado de 
DNS (Domain Name System). Esse serviço age como um grande banco de dados de domínios. Portanto quando
fazemos uma requisição para "alura.com.br" o DNS age transformando para um IP e a requisição prossegue.

- Agora imagine que o servidor é uma casa: dependendo da casa há varias portas disponíveis. O que é pre-
ciso saber é qual porta devemos utilizar quando chegarmos na casa. Ou seja devemos saber qual porta é
utilizada ppara o protocolo HTTP.

- A porta reservada para o protocolo HTTP é o 80. Novamente um número, e como o navegador já sabe essa
porta padrão, podemos omiti-la, mas nada nos impede de adiciona-la no endereço, por exemplo:
http://www.alura.com.br:80

- Se tentarmos colocar uma outra porta, 81 por exemplo, não funciona, pois essa porta não está aberta
no servidor, não podemos estabelecer uma conexão e o tempo de conexão vai se esgotar. Igualmente o pro-
tocolo HTTPS ´pssui uma porta padrão, a porta 443, que também podemos omitir ao acessarmos um endereço
HTTPS.

- Navegando dentro da Alura, mais informações aparecem depois do nome e do domínio. Por exemplo, para 
acessar a página principal dos cursos, usamos https://cursos.alura.com.br/dashboard. O /dashboard é um 
recurso (resource) do site que gostaríamos de acessar. Existem vários outros recursos na Alura como as 
carreiras (/careers), ou o fórum de discussões (/forum). O importante é que cada recurso possua o seu 
nome único.

- Estamos usando regras bem definidas para descrever a localização de um recurso na web. Todos os ende-
reços na web sempre seguem esse mesmo padrão: "protocolo://dominio:porta/caminho/recurso". Esse padrão
na verdade segue uma especificação que foi batizada de Uniform Resource Locator, abreviada como URL.
Então as URLs são os endereços na web.

- Muitas vezes, desenvolvedores usam a sligla URI (Uniform Resourse Identifier) quando falam de endere-
ços na web. Alguns preferem URL, e alguns misturam as duas siglas à vontadae. Há uma certa confusão no 
mercado a respeito e mesmo desenvolvedores experientes não sabem explicar a diferença.

- Uma URL é uma URI. No contexto do desenvolvimento web, ambas as siglas são válidas para falar de ende-
reços na web. As siglas são praticamente sinônimos e são utilizadas dessa forma.

- Uma URL é uma URI, mas nem todas as URIs são URLs que identificam um recurso sem definir o endereço,
nem o protocolo. Em outras palavras uma URL representa a identificação de um recurso (URI) através do 
endereço, mas nem todas as identificações são URLs.

- No mundo HTTP, a requisição enviada pelo navegadro para o servidor é chamada de HTTP REQUEST e a res-
posta é chamada de HTTP RESPONSE. Aqui é importante saber que a comunicação sempre começa com o cliente
ele é quem pede as informações. O servidor responde apenas o que foi requisitado e nunca inicia a comu-
nicação.

- A ideia do HTTP é a de que cada recurso pe independente do outro e não depende do anterior. Isso tam-
bém se aplica para os dados enviados na requisição. Cada requisição pe independente da outra e ela sem-
pre deve conter todas as informações para o servidor responder. Cada requisição precisa ter todas as 
informações, a mesma coisa se aplica para a resposta, precisa ter todas as informações.

- Essa caracteristica de cada requisição ser independente é chamada de stateless. O HTTP é um protocolo
que não mantém o estado de requisições. Isso significa que só com http não há como se lembrar das requi-
sições anteriores enviadas para o servidor.

- Quando efetuamos o login e nossos dados são validados, o servidor tem certeza que o usuário existe e
gera uma identificação quase aleatória para o usuário. Essa identificação é um número criado ao vivo e 
muito dificil de advinhar. Esse número é a identificação temporária do usuário e ele será devolvido na
resposta.

- O navegador grava esse número em um arquivo especial para cada site, são os famosos cookies. Se apa-
garmos esse cookie, perdemos a identificação, sendo assim, o site exigirá um novo login pois não saberá
que já tinhamos logado. Normalmente o nome do cookie é algo como session-id, dependendo da plataforma de 
desenvolvimento utilizada ele pode se chamar de PHPSESSID ou ASP.NET_SessionId ou JSESSIONID ou outro no
me que foi inventado! O Cookie será gerado de forma transparente pela tecnologia que você for utilizar 
para criar aplicativos web. 

- Resumindo, todas as plataformas ajudam a gerar esse número e a criar o cookie de maneira trasparente.
é dessa forma que as plataformas ferenciam SESSÕES com o usuário. A ideia de manter dados entre requi-
sições é algo muito comum no desenvolvimento de aplicações na web. Um usuário que se loga no sistema web
causa a criação de uma sessão. Uma sessão é útil ára guardar informações sobre o usuério e ações dele.

- Requisições com o método GET quer dizer que queremos receber informações sem modificar nada no servi-
dor

- O protocolo HTTP define alguns códigos padrões para esclarecer a resposta. O código 301 significa 
Moved Permanently. Ou seja, o site ffoi movido para outro lugar, dentro do item response Headers podemos
ver todos os cabeçalhos que o servidor devolveu e logo logo apareceu um com o nome Location. Esse cabe-
çalho indica a nova URL, só que agora usando https.

- Quando o navegador recebe o status 301 ele já sabe que é preciso enviar uma nova requisição e procura
a URL no cabeçalho de resposta Location.

- Se alguem acessa a Alura usando http (inseguro) automaticamente é chamado o site seguto (https). Isto
é um comportamento muito comum para garantir que usamos https sempre. Se esquecermos de usar https, o
servidor devolve o status 301 com a nova localização, mas agora usando https. O navegador ao receber
301, chama automaticamente a nova URL. No mundo de desenvolvimento web este comportamento é chamado de
Redirecionamento pelo navegador, ou Redireceionamento no lado do cliente. 

- O código de status 200, um dos mais comuns, significa que tudo deu certo. Dessa vez não foi preciso
fazer nenhum redirecionamento (não tem cabeçalho Location na resposta) e não deu nenhum outro problema.

- O protocolo HTTP não está preso em algum formato especifico. Podemos trafegar qualquer informação com 
ele, seja texto ou binário.

- Se fizermos uma busca por uma página que não existe, o servidor vai retornar o status code 404, que
significa que o servidor não encontrou o recurso (Not Found). 

- Também podem acontecer problemas no lado do servidor, isso é normal pois alguma lógica pode falhar,
erros acontecem no desenvolvimento. Quando algum problema no servidor acontecer, podemos avisar ao clien
te através do protocolo HTTP. O código mais comum para esse tipo de problema é o 500 qye significa:
"deu pau no servidor".

- O importante é saber que algo que começa com 2xx significa coisa boa, a requisição foi executada com 
sucesso. Quando recebemos algo com 3xx normalmente significa que o navegador precisa fazer algo a mais
(o cliente precisa agir) pois algo mudou ou um recurso não existe mais. 4xx significa que o navegador
enviou dados errados, como por exemplo uma URL errada. Caso o servidor gere algum problema, serão uti-
lizados os códigos 5xx. No dia a dia os códigos 200, 404 e 500 são de longe os mais utilizados!

-  Ao fazer uma busca no YouTube, como tem muito conteúdo, vamos persquisar por Ayrton Senna. Repare
que, ao pesquisar no YouTube, a URL mudou um pouco. O recurso acessado pela busca se chama "/results"
(os resultadso da pesquisa) mas agora temos um parâmetro da requisição, indicado pela "?":
https://www.youtube.com/results?search_query=Ayrton+Senna

- O Parâmetro se chama search_query com o valor "Ayrton-Senna". Esses parâmetros da URL normalmente são
chamados de Query Params. O HTTP permite enviar mais de um parâmetro, basta concatenar o proximo parâ-
metro através do caractere "&"

- Uma caracteristica da requisição GET é enviar os parâmetros pela URL, isso é útil quando queremos dei-
xar os parâmetros visíveis. Assim podemos facilmente guardar a URL com os parâmetros para repetir a 
requisição algum momento depois. Mas não é uma boa opção quando queremos enviar credenciais como login e
senha pois eles apareceriam na URL também.

- Ao enviar o login e senha para a alura por exemplo, a url se chama https://www.alura.com.br/signin.
O método HTTP utilizado mudou, Estamos usando o HTTP POST. Usando o POST, o navegador envia os dados do 
formulário no corpo da requisição e não na URL, se fosse um GET, todos os dados seriam enviados através 
dar URL.

- O método POST foi inicialmente pensado para criar algo novo no servidor como criar uma pergunta num
forum por exemplo. Ou seja, ao enviar uma requisição POST para o servidor, a nossa intenção é criar algo
novo. No entanto, nem sempre isso é realmente utilizado dessa maneira. Por exemplo, acabamos de usar um
POST para verificar o login, ou seja, não alteramos ou adicionamos nada. Nossa motivação para o POST era
esconder os parâmetros apenas.

- Como o servidor realmente reage quando recebe uma requisição POST depende da implementação, depende da
lógica atrás. Os métodos como GET e POST definem uma intenção mas o que realmente será executado depende
do servidor.

- No dia a dia, vocês vão ver códigos usando GET para fazer pesquisas mas também para alterar ou remover
algo no servidor. A mesma coisa podemos dizer sobre POST. Vocês vão usar o POST para inserir e alterar 
dados, mas também para pesquisar. As aplicações podem adaptar o significado dos métodos HTTP quando for
necessário.

- Os métodos GET e POST são de longe os métodos mais utilizados no desenvolvimento web, mas porque isso?
A resposta está no nosso HTML, para enviar uma requisição HTTP sem o uso do JavaScript é preciso escre-
ver um código HTML. Em detalhe para enviar uma requisição HTTP devemos usar a tag a ou um from e para
POST devemos sempre usar a tag a. E aí está o problema pois não tem uma forma que permite enviar requi-
sição HTTP pelo HTML a não ser GET e POST. Para usar outros métodos como DELTE ou PUT é preciso progra-
mar em JavaScript e nem sempre isso é desejável.

- O cabeçalho Content-Type, como o próprio nome sugere, traz informações sobre o tipo de conteúdo que 
está sendo trafegado. Logo se formos enviar através do HTTP um conteúdo JSON podemos especificar isso 
através dele. Ele, portanto, não tem relação com o formato esperado na resposta.

- Accept-Language é um cabeçalho que podemos usar para definir a linguagem usada. Usa-se o seguinte 
formato:
Accept-Language: <linguagem-localização(opcional)>
Como em:
Accept-Language: en, Accept-Language: en-US(inglês americano) e 
Accept-Language: pt-BR(português brasileiro)

- Pelo cabeçalho Accept podemos usar algum formato especifico como:
Accept: text/html, Accept: text/css, Accept: application/xml, Accept: application/json, 
Accept:image/jpeg e Accept: image/*

- Logo podemos perceber que o padrão usado pela equipe do websevice define que uma requisição web tem 3
tipos de componentes importantes: recursos (URI), operações (GET, POST, PUT, DELETE/...) e representa-
ção de dados (XML, JSON, ...).

- Esses três componentes em conjuntos seguindo algumas praticas são a base para o modelo arquitetural
REST(representational State Transfer) ou em português Transferência de Estado Representacional.
--------------------------------------------------------------------------------------------------------
--- Recursos --- 

- Ao criar ass URIs do nosso sistema devemos levar em conta que elas representam recursos, não ações. Em
Sistemas REST, nossas URIs devem conter apenas substantivos, que são nossos recursos:
"/restaurante/adiciona" não é uma boa URI, pois contém um verbo e não está indentificando um recurso, 
mas sim uma operação. Para representar a adição de um restaurante podemos usar a URI /restaurante com um
método HTTP POST, que representa que estamos adicionando alguma informação no sistema.

--- Operações ---

- Cada método tem uma semântica diferente e juntando o método à URI deveriamos conseguir representar to-
das as ações do nosso sistema. As semânticas principais são:
GET - recupera informações sobre o recurso identificado pela URI. Ex: listar restaurante, visualizar o 
restaurante 1. Uma requisição GET não deve modificar nenhum recurso do seu sistema, ou seja, não deve 
ter nenhum efeito colateral, você apenas recupera informações do sistema.

POST - adiciona informações usando o recurso da URI passada. Ex: adicionar um restaurante. Pode adicio-
nar informações a um recurso ou criar um novo recurso.

PUT - adiciona (ou modifica) um recurso na URI passada. Ex: atualizar um restaurante.

DELETE - remove o recurso representado pela URI passada. Ex: remover um restaurante.

--- Representações ---

- Quando fazemos uma aplicação não trafegamos um recurso pela rede, apenas uma representação dele.
E essa representação pode ser feita de diferentes formas como JSON, XML ou HTML.

--- Conclusão ---

- Nossas URIs devem representar recursos, as operações no recurso devem ser indicadas pelos métodos HTTP
e podemos falar qual é o formato em que conversamos com o servidor com o Content-Type e Accept que são
cabeçalhos do HTTP.
--------------------------------------------------------------------------------------------------------


- Em alguns cabeçalhos do HTTP devemos especificar algum formato. Os formatos são chamados na documenta-
ção de MIMEtypes. E na definição do cabeçalho usamos a seguinte estrutura: tipo/subtipo. os tipos conhe-
cidos são:
text, image, application, audio e video
e alguns subtipos:
text -> text/plain, text/html, text/css, text/javascript
image -> image/gif, image/png, image/jpeg
audio -> audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav
video -> video/mp4
application -> application/xml,  application/pdf

- Até agora sempre usamos o browser para realizar uma requisição. Mas podemos realizar fora dele usando
a linha de comando. Um programa famoso pra isso é o CURL que já vem instalado por padrão no Linux e no 
MacOS. Para realizar e depurar uma requisição via CURL podemos simplismente executar no terminal o se-
guinte comando: "curl -v www.caelum.com.br"

- Uma saida típica seria:

Fabios-MacBook-Pro:~ fabiopimentel$ curl -v www.caelum.com.br 
* Rebuilt URL to: www.caelum.com.br/
*   Trying 172.217.29.51...
* Connected to www.caelum.com.br (172.217.29.51) port 80 (#0)
> GET / HTTP/1.1
> Host: www.caelum.com.br
> User-Agent: curl/7.49.1
> Accept: */*
> 
< HTTP/1.1 200 OK
< Content-Type: text/html; charset=utf-8
< Vary: Accept-Encoding,User-Agent
< Content-Language: pt-br
< Content-Type: text/html;charset=UTF-8
< X-DNS-Prefetch-Control: on
< X-Cloud-Trace-Context: 3e5e270ee3ab1e79f81b10d2cdef53cd
< Date: Fri, 24 Mar 2017 19:20:12 GMT
< Server: Google Frontend
< Content-Length: 95776
< 
       <!DOCTYPE html>
    <html class="no-js"lang="pt-br"> <head> <title>Caelum | Cursos de Java, .NET, Android, PHP, Scrum, HTML, CSS e JavaScript </title>
    

- Pode-se notar pela saída que temos logo no começo as informações do request efetuado:

> GET / HTTP/1.1
> Host: www.caelum.com.br
> User-Agent: curl/7.49.1
> Accept: */*

- E após essas infos temos o cabeçalho da resposta obtida pelo servidor:

< HTTP/1.1 200 OK
< Content-Type: text/html; charset=utf-8
< Vary: Accept-Encoding,User-Agent
< Content-Language: pt-br
< Content-Type: text/html;charset=UTF-8
< X-DNS-Prefetch-Control: on
< X-Cloud-Trace-Context: 3e5e270ee3ab1e79f81b10d2cdef53cd
< Date: Fri, 24 Mar 2017 19:20:12 GMT
< Server: Google Frontend
< Content-Length: 95776

- Logo depois vem o corpo da resposta (HTML da página requisitada)

- O protocolo que estamos trabalhando até agora foi especificado na década de 90 e de lá até hoje muitas
alterações foram feitas na forma como usamos a internet.

- Com a chegada do mobile novas preocupações apareceram e otimizações são cada vez mais necessárias para
uma boa performace. Por isso uma mudança foi necessária e em 2015 depois de alguns anos de especifica-
ções e reuniões, surgiu a versão 2 desse protocolo chamada de HTTP/2

- A nova versão do protocolo HTTP traz mudanças fundamentais para a Web. Recursos fantásticos que vão 
melhorar muito a performace da Web além de simplificar a vida dos desenvolvedores.

- No HTTP 1.1, para melhorar a performace, habilitávamos o GZIP no servidor para comprimir os dados das
respostas. É uma excelente pratica, mas que precisa ser habilitada explicitamente. No HTTP/2, o GZIP é
padrão e obrigatório.

- Mas, ser você já olhou como funciona uma requisição HTTP, vai notar que só o GZIPpar as respostas re-
solve só metade do problema. Tanto o request quanto o response levam vários cabeçalhos (headers) que não
são comprimidos no HTTP 1.1 e ainda viajam em texto puro.

- Já na nova versão, os headers passam a ser binários e alem disso, são comprimidos usando um algoritmo
chamado HPACK. Isso diminui bastante o volume de dados trafegados nos headers.

- Além de todas essas otmizações para melhorar a performace ainda hoube uma preocupação com a segurança
exigindo TLS por padrão também.

- A partir od HTTP/2, não precisamos repetir os headers, os cabeçalhos que neviamos na requisição ante-
rior. Logo, quando fazemos uma requisição onde teríamos os cabeçalhos exatamente iguais aos da requisi-
ção passada, nós não precisamos enviar novamente esses dados.

- Agora, se temos uma imagem, os cabeçalhos podem mudar, por exemplo, o Host, que pode estar especifica-
do na página principal. Logo na primeira requisição, o conteúdo HTML es´pecificou que tem que buscar uma
imagem no Host, que é "image.caelum.com.br", um subdomínio dentro da nossa aplicação. Então esse cabe-
çalho terá que ser alterado, logo enviaremos apenas os cabeçalhos que são difirentes. Isso está especi-
ficado no HTTP2, para que uma requisição fique mais leve e não onere tanto o nosso usuário. Isso é co-
nhecido como Headers Stateful.

- No inicio do curso, comentamos que o HTTP era stateless, ou seja, ele não guarda informações passadas.
E isso continua valendo, mas no caso dos cabeçalhos, esxite um ambiente que guarda estado.

- No HTTP2 houve uma mudança em como as requisições entre cliente e servidor funcionam. Agora temos uma
conversa masi paralela. Anteriormente estávamos trabalhando com conceitos de requisições seriais, fazía-
mos uma requisição e esperávamos receber e por aí vai. No HTTP2, quando o cliente realiza uma requisição
para *index.html, o servidor devolve a página, mas ele já pode passar para o browser as informações ne-
cessárias para que essa página possa ser, de fato, exibida. Ou seja, ele consegue dar um passo além.

- Isso é outra abordagem que surgiou no HTTP2, muito mais interessante. Mas quando o browser for inter-
pretar essa página HTML, vair ter que passar pelo conteúdo que especifica o arquivo CSS? Sim, mas quando
ele passar pelo estilo.css, vai verificar que já recebeu. Ou seja, ele percebe que já recebeu essas in-
formações. Esse é o conceito de Server Push, ou seja, o server envia dados para o cliente sem que o 
cliente tenha solicitado, tornando o tráfego de dados muito mais otmizado.

- No modelo request e response, antes da requisição ser feita, há uma conexão, comunicação entre o clien
te e o servidor, que chamamos de TCP. Para que consegamos realizar uma requisição via HTTP, antes existe
o modelo de TCP, que é um protocolo de trasporte. Isso é mais a nível de infraestrutura. Cada requisição
deveria abrir uma conexão TCP, executar e fechar. Mas isso seria muito ruim pois a conexão TCP é um re-
curso muito caro e demora a ser alocado.

- Então o que acontece, no HTTP1 exite um mecanismo chamado de "Keep-Alive" que determina quanto tempo,
por exemplo, a nossa conexão pode ficar ativa. Ou seja, não encerra essa conexão TCP. Portanto consegui-
mos realizer várias requisições com a mesma conexão TCP. Hoje a maioria dos browsers tem um número entre
4 a 8 conexões simultâneas por domínio.

- O "Keep-Alive" continua existindo no HTTP2, só que ele trouxe uma novidade. Por exemplo, se temos uma
conexão TCP aberta e realizarmos uma requisição, poderíamos já dar prosseguimento às próximas requisi-
ções, isso em paralelo, sem de fato ficar esperando o resultado dela, de maniera assíncrona, e vamos re-
cebendo essas respostas à medida em que o servidor for conseguindo processar.

- Então, essas requisições e respostas vão chegando a todo tempo. É totalmente paralelo. A mesma coisa 
acontece com o servidor, não precisamos esperar uma resposta para enviar outra. Se já está pronta para 
ser enviada, ele já envia diretamente.

- Esse conceito que surgiu no HTTP2 é chamado de Multiplexing e traz uma performance bastante relevante
para o nosso HTTP.


 


